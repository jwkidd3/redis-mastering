<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Redis Integration</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/white.min.css">
    <style>
        .reveal {
            font-size: 32px;
        }
        .reveal h1 {
            font-size: 2.2em;
            color: #333;
        }
        .reveal h2 {
            font-size: 1.8em;
            color: #333;
        }
        .reveal h3 {
            font-size: 1.3em;
            color: #555;
        }
        .reveal h4 {
            font-size: 1.1em;
            color: #666;
        }
        .title-slide {
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
        }
        .section-header {
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
        }
        .lab-callout {
            background: #4CAF50;
            color: white;
            padding: 30px;
            border-radius: 10px;
        }
        .lab-callout h2, .lab-callout h3, .lab-callout p {
            color: white !important;
        }
        .reveal pre {
            font-size: 0.55em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-height: 500px;
        }
        .reveal pre code {
            max-height: 500px;
            padding: 15px;
        }
        .reveal ul {
            display: block;
            margin-left: 1em;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .reveal li {
            margin-bottom: 0.3em;
        }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            font-size: 0.85em;
        }
        .code-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .code-comparison pre {
            font-size: 0.5em;
        }
        .highlight-box {
            background: #f0f0f0;
            border-left: 4px solid #4CAF50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .reveal .progress {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section class="title-slide">
                <h1>JavaScript Redis Integration</h1>
                <h3>Day 2 - Session 1</h3>
                <p>Building Applications with Node.js and Redis</p>
            </section>

            <!-- Section: Introduction -->
            <section class="section-header">
                <h2>Node.js Redis Client</h2>
                <p>Modern JavaScript Integration</p>
            </section>

            <!-- Why JavaScript with Redis -->
            <section>
                <h2>Why JavaScript + Redis?</h2>
                <ul>
                    <li>Native async/await support</li>
                    <li>Event-driven architecture alignment</li>
                    <li>JSON handling capabilities</li>
                    <li>Large ecosystem of packages</li>
                    <li>Full-stack development</li>
                    <li>Real-time application support</li>
                </ul>
            </section>

            <!-- Node Redis Client -->
            <section>
                <h2>Node Redis Client Options</h2>
                <div class="two-column">
                    <div>
                        <h4>node-redis (Official)</h4>
                        <ul>
                            <li>Official Redis client</li>
                            <li>Promise-based API</li>
                            <li>TypeScript support</li>
                            <li>Redis 7+ features</li>
                        </ul>
                    </div>
                    <div>
                        <h4>ioredis</h4>
                        <ul>
                            <li>Feature-rich client</li>
                            <li>Cluster support</li>
                            <li>Sentinel support</li>
                            <li>Pipeline optimization</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Installation -->
            <section>
                <h2>Installation & Setup</h2>
                <pre><code class="bash">
# Create new Node.js project
mkdir redis-app && cd redis-app
npm init -y

# Install Redis client
npm install redis

# Install development dependencies
npm install -D nodemon dotenv

# Create basic structure
touch index.js .env
                </code></pre>
            </section>

            <!-- Section: Connection Management -->
            <section class="section-header">
                <h2>Connection Management</h2>
                <p>Establishing and Managing Redis Connections</p>
            </section>

            <!-- Basic Connection -->
            <section>
                <h2>Basic Connection</h2>
                <pre><code class="javascript">
import { createClient } from 'redis';

// Create client
const client = createClient({
    url: 'redis://localhost:6379'
});

// Handle events
client.on('error', err => console.log('Redis Error', err));
client.on('connect', () => console.log('Connected to Redis'));
client.on('ready', () => console.log('Redis client ready'));

// Connect
await client.connect();
                </code></pre>
            </section>

            <!-- Connection Options -->
            <section>
                <h2>Connection Options</h2>
                <pre><code class="javascript">
const client = createClient({
    url: 'redis://localhost:6379',
    password: 'your-password',
    database: 0,
    socket: {
        connectTimeout: 5000,
        keepAlive: 10000
    },
    commandsQueueMaxLength: 100
});
                </code></pre>
            </section>

            <!-- Connection Pooling -->
            <section>
                <h2>Connection Pool Pattern</h2>
                <pre><code class="javascript">
class RedisPool {
    constructor(config) {
        this.clients = [];
        this.config = config;
        this.maxClients = config.maxClients || 10;
    }
    
    async getClient() {
        if (this.clients.length > 0) {
            return this.clients.pop();
        }
        const client = createClient(this.config);
        await client.connect();
        return client;
    }
    
    releaseClient(client) {
        if (this.clients.length < this.maxClients) {
            this.clients.push(client);
        } else {
            client.quit();
        }
    }
}
                </code></pre>
            </section>

            <!-- Section: Basic Operations -->
            <section class="section-header">
                <h2>Basic Operations</h2>
                <p>CRUD Operations with JavaScript</p>
            </section>

            <!-- String Operations -->
            <section>
                <h2>String Operations</h2>
                <pre><code class="javascript">
// Set and Get
await client.set('user:1001', 'John Doe');
const user = await client.get('user:1001');

// Set with expiry (seconds)
await client.setEx('session:abc123', 3600, 'user-data');

// Set if not exists
const wasSet = await client.setNX('lock:resource', '1');

// Increment/Decrement
await client.incr('page:views');
await client.incrBy('score:player1', 10);
                </code></pre>
            </section>

            <!-- JSON Operations -->
            <section>
                <h2>Working with JSON</h2>
                <pre><code class="javascript">
// Store JSON object
const userData = {
    id: 1001,
    name: 'John Doe',
    email: 'john@example.com',
    preferences: { theme: 'dark' }
};

await client.set(
    'user:1001:data', 
    JSON.stringify(userData)
);

// Retrieve and parse
const jsonStr = await client.get('user:1001:data');
const parsed = JSON.parse(jsonStr);
                </code></pre>
            </section>

            <!-- Hash Operations -->
            <section>
                <h2>Hash Operations</h2>
                <pre><code class="javascript">
// Set multiple hash fields
await client.hSet('user:1001', {
    name: 'John Doe',
    email: 'john@example.com',
    age: '30'
});

// Get specific field
const email = await client.hGet('user:1001', 'email');

// Get all fields
const userData = await client.hGetAll('user:1001');

// Increment hash field
await client.hIncrBy('user:1001', 'loginCount', 1);
                </code></pre>
            </section>

            <!-- List Operations -->
            <section>
                <h2>List Operations</h2>
                <pre><code class="javascript">
// Push to list
await client.lPush('queue:tasks', 'task1');
await client.rPush('queue:tasks', 'task2');

// Pop from list
const task = await client.lPop('queue:tasks');

// Blocking pop (wait up to 5 seconds)
const result = await client.blPop(
    'queue:tasks', 
    5
);

// Get range
const tasks = await client.lRange('queue:tasks', 0, -1);
                </code></pre>
            </section>

            <!-- Set Operations -->
            <section>
                <h2>Set Operations</h2>
                <pre><code class="javascript">
// Add to set
await client.sAdd('tags:post:1', ['redis', 'database', 'nosql']);

// Check membership
const isMember = await client.sIsMember('tags:post:1', 'redis');

// Get all members
const tags = await client.sMembers('tags:post:1');

// Set operations
const common = await client.sInter(['tags:post:1', 'tags:post:2']);
await client.sUnionStore('tags:all', ['tags:post:1', 'tags:post:2']);
                </code></pre>
            </section>

            <!-- Section: Async Patterns -->
            <section class="section-header">
                <h2>Async Patterns</h2>
                <p>Modern JavaScript Patterns with Redis</p>
            </section>

            <!-- Promise Patterns -->
            <section>
                <h2>Promise-Based Operations</h2>
                <pre><code class="javascript">
// Parallel operations with Promise.all
const results = await Promise.all([
    client.get('key1'),
    client.get('key2'),
    client.get('key3')
]);

// Sequential with error handling
try {
    await client.set('key', 'value');
    const value = await client.get('key');
    await client.del('key');
} catch (error) {
    console.error('Redis operation failed:', error);
}
                </code></pre>
            </section>

            <!-- Async/Await Patterns -->
            <section>
                <h2>Async Function Patterns</h2>
                <pre><code class="javascript">
class UserService {
    constructor(redisClient) {
        this.redis = redisClient;
    }
    
    async getUser(userId) {
        const cached = await this.redis.get(`user:${userId}`);
        if (cached) {
            return JSON.parse(cached);
        }
        
        // Fetch from database
        const user = await db.findUser(userId);
        
        // Cache for 1 hour
        await this.redis.setEx(
            `user:${userId}`,
            3600,
            JSON.stringify(user)
        );
        
        return user;
    }
}
                </code></pre>
            </section>

            <!-- Section: Transactions -->
            <section class="section-header">
                <h2>Transactions & Pipelines</h2>
                <p>Atomic Operations and Performance</p>
            </section>

            <!-- Transactions -->
            <section>
                <h2>Redis Transactions</h2>
                <pre><code class="javascript">
// Multi/Exec transaction
const multi = client.multi();

multi.incr('counter');
multi.expire('counter', 60);
multi.get('counter');

const results = await multi.exec();
// results = [1, true, '1']

// With watch for optimistic locking
await client.watch('balance');
const balance = await client.get('balance');

if (parseInt(balance) >= 100) {
    const multi = client.multi();
    multi.decrBy('balance', 100);
    multi.incrBy('spent', 100);
    await multi.exec();
}
                </code></pre>
            </section>

            <!-- Pipelines -->
            <section>
                <h2>Pipeline for Performance</h2>
                <pre><code class="javascript">
// Without pipeline - multiple round trips
for (let i = 0; i < 1000; i++) {
    await client.set(`key:${i}`, `value:${i}`);
}

// With pipeline - single round trip
const pipeline = client.multi();
for (let i = 0; i < 1000; i++) {
    pipeline.set(`key:${i}`, `value:${i}`);
}
await pipeline.exec();

// Performance difference: ~10x faster
                </code></pre>
            </section>

            <!-- Section: Error Handling -->
            <section class="section-header">
                <h2>Error Handling</h2>
                <p>Robust Error Management</p>
            </section>

            <!-- Error Handling Patterns -->
            <section>
                <h2>Error Handling Strategies</h2>
                <pre><code class="javascript">
class RedisService {
    async safeGet(key, defaultValue = null) {
        try {
            const value = await this.client.get(key);
            return value || defaultValue;
        } catch (error) {
            console.error(`Failed to get ${key}:`, error);
            return defaultValue;
        }
    }
    
    async withRetry(operation, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await operation();
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                await new Promise(r => setTimeout(r, 100 * Math.pow(2, i)));
            }
        }
    }
}
                </code></pre>
            </section>

            <!-- Connection Error Handling -->
            <section>
                <h2>Connection Resilience</h2>
                <pre><code class="javascript">
const client = createClient({
    socket: {
        reconnectStrategy: (retries) => {
            if (retries > 10) {
                return new Error('Too many retries');
            }
            return Math.min(retries * 100, 3000);
        }
    }
});

client.on('error', (err) => {
    console.error('Redis Client Error:', err);
});

client.on('reconnecting', () => {
    console.log('Reconnecting to Redis...');
});
                </code></pre>
            </section>

            <!-- Lab 6 Callout -->
            <section class="lab-callout">
                <h2>🧪 Lab 6</h2>
                <h3>JavaScript Redis Client Setup</h3>
                <p><strong>Duration: 45 minutes</strong></p>
                <p>Build your first Node.js Redis application</p>
            </section>

            <!-- Section: Advanced Patterns -->
            <section class="section-header">
                <h2>Advanced Patterns</h2>
                <p>Production-Ready Implementations</p>
            </section>

            <!-- Caching Pattern -->
            <section>
                <h2>Cache-Aside Pattern</h2>
                <pre><code class="javascript">
class CacheService {
    constructor(redis, ttl = 3600) {
        this.redis = redis;
        this.ttl = ttl;
    }
    
    async get(key, fetchFn) {
        // Try cache first
        const cached = await this.redis.get(key);
        if (cached) {
            return JSON.parse(cached);
        }
        
        // Fetch fresh data
        const data = await fetchFn();
        
        // Store in cache
        await this.redis.setEx(
            key,
            this.ttl,
            JSON.stringify(data)
        );
        
        return data;
    }
}
                </code></pre>
            </section>

            <!-- Pub/Sub Pattern -->
            <section>
                <h2>Pub/Sub Implementation</h2>
                <pre><code class="javascript">
// Publisher
const publisher = createClient();
await publisher.connect();

await publisher.publish('notifications', JSON.stringify({
    type: 'alert',
    message: 'New message received'
}));

// Subscriber
const subscriber = createClient();
await subscriber.connect();

await subscriber.subscribe('notifications', (message) => {
    const data = JSON.parse(message);
    console.log('Received:', data);
});
                </code></pre>
            </section>

            <!-- Rate Limiting -->
            <section>
                <h2>Rate Limiting Pattern</h2>
                <pre><code class="javascript">
async function rateLimit(userId, limit = 10, window = 60) {
    const key = `rate:${userId}:${Date.now() / 1000 / window | 0}`;
    
    const current = await client.incr(key);
    
    if (current === 1) {
        await client.expire(key, window);
    }
    
    if (current > limit) {
        throw new Error('Rate limit exceeded');
    }
    
    return {
        remaining: limit - current,
        reset: window
    };
}
                </code></pre>
            </section>

            <!-- Session Management -->
            <section>
                <h2>Session Management</h2>
                <pre><code class="javascript">
class SessionManager {
    async create(userId, data) {
        const sessionId = crypto.randomUUID();
        const key = `session:${sessionId}`;
        
        await this.redis.hSet(key, {
            userId,
            created: Date.now(),
            ...data
        });
        
        await this.redis.expire(key, 3600);
        return sessionId;
    }
    
    async get(sessionId) {
        const key = `session:${sessionId}`;
        const data = await this.redis.hGetAll(key);
        
        if (Object.keys(data).length === 0) {
            return null;
        }
        
        // Extend session
        await this.redis.expire(key, 3600);
        return data;
    }
}
                </code></pre>
            </section>

            <!-- Section: Performance -->
            <section class="section-header">
                <h2>Performance Optimization</h2>
                <p>Best Practices for Production</p>
            </section>

            <!-- Performance Tips -->
            <section>
                <h2>Performance Best Practices</h2>
                <ul>
                    <li>Use pipelining for batch operations</li>
                    <li>Implement connection pooling</li>
                    <li>Set appropriate timeouts</li>
                    <li>Use SCAN instead of KEYS</li>
                    <li>Compress large values</li>
                    <li>Monitor slow queries</li>
                    <li>Use appropriate data structures</li>
                </ul>
            </section>

            <!-- Monitoring -->
            <section>
                <h2>Monitoring & Metrics</h2>
                <pre><code class="javascript">
class RedisMonitor {
    constructor(client) {
        this.client = client;
        this.metrics = {
            commands: 0,
            errors: 0,
            latency: []
        };
    }
    
    async executeWithMetrics(command, ...args) {
        const start = Date.now();
        this.metrics.commands++;
        
        try {
            const result = await this.client[command](...args);
            this.metrics.latency.push(Date.now() - start);
            return result;
        } catch (error) {
            this.metrics.errors++;
            throw error;
        }
    }
}
                </code></pre>
            </section>

            <!-- Testing -->
            <section>
                <h2>Testing Redis Code</h2>
                <pre><code class="javascript">
// Mock Redis for testing
class MockRedis {
    constructor() {
        this.data = new Map();
    }
    
    async set(key, value) {
        this.data.set(key, value);
        return 'OK';
    }
    
    async get(key) {
        return this.data.get(key) || null;
    }
}

// Test example
describe('UserService', () => {
    it('should cache user data', async () => {
        const redis = new MockRedis();
        const service = new UserService(redis);
        
        const user = await service.getUser(1);
        expect(redis.data.has('user:1')).toBe(true);
    });
});
                </code></pre>
            </section>

            <!-- Summary -->
            <section>
                <h2>Key Takeaways</h2>
                <ul>
                    <li>Node Redis client provides full async/await support</li>
                    <li>Use appropriate patterns for your use case</li>
                    <li>Implement proper error handling</li>
                    <li>Optimize with pipelines and transactions</li>
                    <li>Monitor performance in production</li>
                    <li>Test with mock implementations</li>
                </ul>
            </section>

            <!-- Lab 7 Callout -->
            <section class="lab-callout">
                <h2>🧪 Lab 7</h2>
                <h3>Customer Profiles with Hashes</h3>
                <p><strong>Duration: 45 minutes</strong></p>
                <p>Implement customer data management using Redis hashes</p>
            </section>

            <!-- End Slide -->
            <section class="section-header">
                <h2>Next Up</h2>
                <h3>Advanced Data Structures</h3>
                <p>Lists, Sets, and Sorted Sets in JavaScript</p>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            controls: true,
            progress: true,
            center: true,
            transition: 'slide',
            plugins: [RevealHighlight],
            width: 1920,
            height: 1080,
            margin: 0.04,
            minScale: 0.2,
            maxScale: 2.0
        });
    </script>
</body>
</html>