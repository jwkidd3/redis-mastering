<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Content 4: JavaScript Redis Integration</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/white.min.css">
    <style>
        .reveal .slides section {
            text-align: left;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 0.5em;
        }
        .main-title {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white !important;
            padding: 2em;
            border-radius: 10px;
            text-align: center;
        }
        .session-header {
            background: #f8f9fa;
            color: #2c3e50 !important;
            padding: 1em;
            border-left: 5px solid #3498db;
            margin-bottom: 1em;
        }
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 1em;
            font-family: 'Courier New', 'Monaco', monospace;
            font-size: 0.7em;
            margin: 0.5em 0;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .highlight {
            background: #ffffcc;
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        .lab-callout {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white !important;
            padding: 1.5em;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
            margin: 1em 0;
        }
        .bullet-point {
            margin: 0.4em 0;
            line-height: 1.5;
        }
        .two-column {
            display: flex;
            gap: 2em;
        }
        .column {
            flex: 1;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 0.8em;
            margin: 0.5em 0;
            font-size: 0.8em;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 5px;
            padding: 0.8em;
            margin: 0.5em 0;
            font-size: 0.8em;
        }
        .info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 5px;
            padding: 0.8em;
            margin: 0.5em 0;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section>
                <div class="main-title">
                    <h1>Content 4: JavaScript Redis Integration</h1>
                    <h2>Building Applications with Node.js & Redis</h2>
                    <p><strong>Focus:</strong> JavaScript client libraries and application development</p>
                </div>
            </section>

            <!-- Session Overview -->
            <section>
                <div class="session-header">
                    <h2>Session Objectives</h2>
                </div>
                <ul>
                    <li class="bullet-point">Set up and configure Node.js Redis client</li>
                    <li class="bullet-point">Implement asynchronous Redis operations</li>
                    <li class="bullet-point">Build data management applications</li>
                    <li class="bullet-point">Handle connections and error management</li>
                    <li class="bullet-point">Create customer and policy data workflows</li>
                </ul>
            </section>

            <!-- Node.js Redis Client Setup -->
            <section>
                <div class="session-header">
                    <h3>Node.js Redis Client Setup</h3>
                </div>
                <h4>Installing the Redis Client</h4>
                <p>The official Redis client for Node.js provides comprehensive support for all Redis features with modern async/await syntax.</p>
                
                <h4>Connection Overview</h4>
                <ul>
                    <li class="bullet-point">Install the official Redis client package</li>
                    <li class="bullet-point">Configure connection to remote Redis instance</li>
                    <li class="bullet-point">Set up proper error handling and event listeners</li>
                    <li class="bullet-point">Implement connection monitoring and recovery</li>
                </ul>
                
                <div class="info">
                    <strong>Important:</strong> Always handle connection events to monitor Redis connectivity status in your application.
                </div>
            </section>

            <!-- Node.js Setup Code Examples -->
            <section>
                <div class="session-header">
                    <h3>Node.js Redis Setup - Code Examples</h3>
                </div>
                <h4>Package Installation</h4>
                <div class="code-block">
npm install redis
</div>
                <h4>Basic Connection Setup</h4>
                <div class="code-block">
const redis = require('redis');

const client = redis.createClient({
    host: 'your-redis-host',
    port: 6379,
    password: 'your-password'
});

client.on('error', (err) => {
    console.log('Redis Client Error', err);
});

client.on('connect', () => {
    console.log('Connected to Redis successfully');
});

await client.connect();
</div>
            </section>

            <!-- Connection Configuration -->
            <section>
                <div class="session-header">
                    <h3>Connection Configuration Options</h3>
                </div>
                <h4>Production-Ready Connection Settings</h4>
                <p>Configure robust connection handling with retry logic and timeout management for production environments.</p>
                
                <h4>Key Configuration Areas</h4>
                <ul>
                    <li class="bullet-point"><strong>Retry Strategy:</strong> Implement exponential backoff for reconnection attempts</li>
                    <li class="bullet-point"><strong>Timeout Management:</strong> Set appropriate connection and command timeouts</li>
                    <li class="bullet-point"><strong>Error Handling:</strong> Handle different types of connection errors gracefully</li>
                    <li class="bullet-point"><strong>Security:</strong> Configure authentication and SSL/TLS when required</li>
                </ul>
                
                <div class="warning">
                    <strong>Best Practice:</strong> Implement exponential backoff for reconnection attempts to avoid overwhelming the Redis server during outages.
                </div>
            </section>

            <!-- Connection Configuration Code -->
            <section>
                <div class="session-header">
                    <h3>Connection Configuration - Code Example</h3>
                </div>
                <h4>Advanced Connection Setup</h4>
                <div class="code-block">
const client = redis.createClient({
    url: 'redis://your-redis-host:6379',
    socket: {
        reconnectStrategy: (retries) => 
            Math.min(retries * 50, 500)
    },
    retry_strategy: (options) => {
        if (options.error && 
            options.error.code === 'ECONNREFUSED') {
            return new Error('Redis server refused connection');
        }
        if (options.total_retry_time > 1000 * 60 * 60) {
            return new Error('Retry time exhausted');
        }
        return Math.min(options.attempt * 100, 3000);
    }
});
</div>
            </section>

            <!-- Basic Operations Concepts -->
            <section>
                <div class="session-header">
                    <h3>Fundamental Redis Operations in JavaScript</h3>
                </div>
                <h4>String Operations - Core Data Storage</h4>
                <p>String operations form the foundation of Redis data manipulation. These operations are atomic and provide excellent performance for simple key-value storage.</p>
                
                <h4>Key String Operation Types</h4>
                <ul>
                    <li class="bullet-point"><strong>SET/GET:</strong> Basic key-value storage and retrieval</li>
                    <li class="bullet-point"><strong>MSET/MGET:</strong> Batch operations for multiple keys</li>
                    <li class="bullet-point"><strong>SETEX:</strong> Set with automatic expiration (TTL)</li>
                    <li class="bullet-point"><strong>INCR/DECR:</strong> Atomic numeric operations</li>
                </ul>
                
                <div class="info">
                    <strong>Performance Tip:</strong> Use mSet and mGet for batch operations to reduce network round trips and improve application performance.
                </div>
            </section>

            <!-- Basic Operations Code -->
            <section>
                <div class="session-header">
                    <h3>String Operations - Code Examples</h3>
                </div>
                <div class="code-block">
// Set a single value
await client.set('customer:1001:name', 'John Doe');

// Retrieve the stored value
const customerName = await client.get('customer:1001:name');
console.log('Customer Name:', customerName);

// Set value with expiration (TTL in seconds)
await client.setEx('session:abc123', 3600, 
    'active_user_session');

// Set multiple key-value pairs
await client.mSet({
    'customer:1001:email': 'john.doe@email.com',
    'customer:1001:status': 'active',
    'customer:1002:name': 'Jane Smith'
});

// Retrieve multiple values efficiently
const customerData = await client.mGet([
    'customer:1001:name', 
    'customer:1001:email'
]);
</div>
            </section>

            <!-- Working with JSON Data Concepts -->
            <section>
                <div class="session-header">
                    <h3>Working with Complex JSON Data</h3>
                </div>
                <h4>Storing and Retrieving JavaScript Objects</h4>
                <p>Redis stores data as strings, so JavaScript objects must be serialized. JSON serialization provides a simple way to store complex data structures.</p>
                
                <h4>JSON Storage Considerations</h4>
                <ul>
                    <li class="bullet-point"><strong>Serialization:</strong> Convert objects to JSON strings for storage</li>
                    <li class="bullet-point"><strong>Deserialization:</strong> Parse JSON strings back to objects</li>
                    <li class="bullet-point"><strong>Performance:</strong> Good for read-heavy workloads</li>
                    <li class="bullet-point"><strong>Limitations:</strong> Requires full object rewrite for updates</li>
                </ul>
                
                <div class="warning">
                    <strong>Consideration:</strong> JSON serialization works well for read-heavy workloads, but consider Redis hashes for frequently updated fields to avoid full object rewrites.
                </div>
            </section>

            <!-- JSON Data Code Examples -->
            <section>
                <div class="session-header">
                    <h3>JSON Data - Code Examples</h3>
                </div>
                <div class="code-block">
const customerData = {
    id: 1001,
    name: 'John Doe',
    email: 'john.doe@email.com',
    policies: [
        { id: 'POL001', type: 'auto', premium: 1200 },
        { id: 'POL002', type: 'home', premium: 800 }
    ],
    preferences: { notifications: true, paperless: true },
    lastLogin: new Date().toISOString(),
    loyaltyPoints: 2500
};

// Store complex object as JSON string
await client.set('customer:1001:profile', 
    JSON.stringify(customerData));

// Retrieve and deserialize
const storedData = await client.get('customer:1001:profile');
const customer = JSON.parse(storedData);

console.log('Customer policies:', customer.policies.length);
console.log('Total premium:', 
    customer.policies.reduce((sum, policy) => 
        sum + policy.premium, 0));
</div>
            </section>

            <!-- Hash Operations Concepts -->
            <section>
                <div class="session-header">
                    <h3>Redis Hash Operations - Structured Data</h3>
                </div>
                <h4>Efficient Field-Level Data Management</h4>
                <p>Redis hashes provide an efficient way to store objects with multiple fields, allowing atomic updates to individual properties without affecting the entire record.</p>
                
                <h4>Hash Operation Benefits</h4>
                <ul>
                    <li class="bullet-point"><strong>Partial Updates:</strong> Modify individual fields without rewriting entire objects</li>
                    <li class="bullet-point"><strong>Memory Efficient:</strong> Optimized storage for small to medium-sized objects</li>
                    <li class="bullet-point"><strong>Atomic Operations:</strong> Field-level operations are atomic</li>
                    <li class="bullet-point"><strong>Type Flexibility:</strong> Store different data types in the same hash</li>
                </ul>
                
                <div class="success">
                    <strong>Use Case:</strong> Hashes are perfect for customer profiles, configuration settings, and any data where you need to update individual fields frequently.
                </div>
            </section>

            <!-- Hash Operations Code Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Hash Operations - Basic Examples</h3>
                </div>
                <div class="code-block">
// Set multiple hash fields atomically
await client.hSet('customer:1001:details', {
    'name': 'John Doe',
    'email': 'john.doe@email.com',
    'phone': '+1-555-0123',
    'status': 'active',
    'premium_member': 'true',
    'join_date': '2020-01-15',
    'last_contact': new Date().toISOString()
});

// Retrieve specific field
const customerName = await client.hGet(
    'customer:1001:details', 'name');
const isPremium = await client.hGet(
    'customer:1001:details', 'premium_member');

// Get all customer fields as object
const customerDetails = await client.hGetAll(
    'customer:1001:details');
console.log('Complete customer record:', customerDetails);

// Atomically increment numeric fields
await client.hIncrBy('customer:1001:stats', 'login_count', 1);
await client.hIncrByFloat('customer:1001:stats', 
    'total_premium', 150.75);
</div>
            </section>

            <!-- Hash Operations Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Hash Operations</h3>
                </div>
                <h4>Selective Updates and Field Management</h4>
                <p>Hash operations excel at partial updates and field-specific operations, making them ideal for frequently changing data.</p>
                
                <h4>Advanced Hash Features</h4>
                <ul>
                    <li class="bullet-point"><strong>Selective Updates:</strong> Update only specific fields as needed</li>
                    <li class="bullet-point"><strong>Field Existence:</strong> Check if fields exist before operations</li>
                    <li class="bullet-point"><strong>Field Management:</strong> Add, remove, and count fields dynamically</li>
                    <li class="bullet-point"><strong>Batch Retrieval:</strong> Get multiple fields in single operation</li>
                </ul>
            </section>

            <!-- Hash Operations Code Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Hash Operations - Code Examples</h3>
                </div>
                <div class="code-block">
// Update only specific fields
await client.hSet('customer:1001:details', {
    'last_login': new Date().toISOString(),
    'status': 'active'
});

// Get multiple specific fields efficiently
const contactInfo = await client.hmGet(
    'customer:1001:details', ['name', 'email', 'phone']);

// Get all field names (keys) in the hash
const fieldNames = await client.hKeys('customer:1001:details');
console.log('Available fields:', fieldNames);

// Count total fields in customer record
const fieldCount = await client.hLen('customer:1001:details');

// Delete specific fields
await client.hDel('customer:1001:details', 'temporary_note');

// Check if specific field exists
const hasPhone = await client.hExists(
    'customer:1001:details', 'phone');
</div>
            </section>

            <!-- List Operations Concepts -->
            <section>
                <div class="session-header">
                    <h3>Redis List Operations - Ordered Collections</h3>
                </div>
                <h4>Managing Sequential and Time-Ordered Data</h4>
                <p>Redis lists maintain insertion order and provide efficient operations at both ends, making them perfect for activity logs, queues, and chronological data.</p>
                
                <h4>List Operation Categories</h4>
                <ul>
                    <li class="bullet-point"><strong>Push/Pop Operations:</strong> Add and remove items from either end</li>
                    <li class="bullet-point"><strong>Range Operations:</strong> Retrieve specific ranges of items</li>
                    <li class="bullet-point"><strong>Index Operations:</strong> Access items by position</li>
                    <li class="bullet-point"><strong>Blocking Operations:</strong> Wait for items in real-time processing</li>
                </ul>
                
                <div class="info">
                    <strong>Queue Pattern:</strong> Use LPUSH + BRPOP for FIFO queues, or RPUSH + BLPOP for LIFO stacks. Blocking operations enable real-time task processing.
                </div>
            </section>

            <!-- List Operations Code Part 1 -->
            <section>
                <div class="session-header">
                    <h3>List Operations - Basic Examples</h3>
                </div>
                <div class="code-block">
// Add new items to the beginning (left) of list
await client.lPush('customer:1001:claims', 'CLM003_2024');
await client.lPush('customer:1001:claims', 'CLM004_2024');

// Add items to the end (right) of the list
await client.rPush('customer:1001:activities', 
    JSON.stringify({
        action: 'policy_update',
        timestamp: Date.now(),
        details: 'Updated contact information'
    })
);

// Retrieve range of items (0 = first, -1 = last)
const recentClaims = await client.lRange(
    'customer:1001:claims', 0, 4);
console.log('Last 5 claims:', recentClaims);

// Get specific item by index (0-based)
const latestClaim = await client.lIndex(
    'customer:1001:claims', 0);

// Remove and return items from either end
const processedClaim = await client.lPop('customer:1001:claims');
const oldestActivity = await client.rPop('customer:1001:activities');
</div>
            </section>

            <!-- List Operations Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced List Operations</h3>
                </div>
                <h4>List Manipulation and Queue Operations</h4>
                <p>Lists support advanced operations for queue management, data cleaning, and complex list manipulations.</p>
                
                <h4>Advanced List Features</h4>
                <ul>
                    <li class="bullet-point"><strong>List Trimming:</strong> Keep only recent items for log rotation</li>
                    <li class="bullet-point"><strong>Item Insertion:</strong> Insert items at specific positions</li>
                    <li class="bullet-point"><strong>Value Removal:</strong> Remove specific values from lists</li>
                    <li class="bullet-point"><strong>Blocking Operations:</strong> Real-time queue processing</li>
                </ul>
            </section>

            <!-- List Operations Code Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced List Operations - Code Examples</h3>
                </div>
                <div class="code-block">
// Get list length for pagination or validation
const claimCount = await client.lLen('customer:1001:claims');
console.log(`Customer has ${claimCount} claims on record`);

// Trim list to keep only recent items (useful for logs)
await client.lTrim('customer:1001:activities', 0, 99); // Keep last 100

// Insert item before or after existing element
await client.lInsert('customer:1001:claims', 'BEFORE', 
    'CLM003_2024', 'CLM002_2024');

// Remove specific items by value (count: positive = from head)
await client.lRem('customer:1001:claims', 1, 'CLM001_CANCELLED');

// Set value at specific index
await client.lSet('customer:1001:claims', 0, 'CLM004_UPDATED');

// Blocking operations for real-time processing
// Note: Use separate connection for blocking operations
const blockingClient = client.duplicate();
const nextItem = await blockingClient.blPop('work_queue', 30); // 30 sec timeout
</div>
            </section>

            <!-- Set Operations Concepts -->
            <section>
                <div class="session-header">
                    <h3>Redis Set Operations - Unique Collections</h3>
                </div>
                <h4>Managing Unique Values and Set Mathematics</h4>
                <p>Redis sets automatically ensure uniqueness and provide powerful set operations for data analysis and relationship management.</p>
                
                <h4>Set Operation Categories</h4>
                <ul>
                    <li class="bullet-point"><strong>Membership Operations:</strong> Add, remove, and check set membership</li>
                    <li class="bullet-point"><strong>Set Mathematics:</strong> Union, intersection, and difference operations</li>
                    <li class="bullet-point"><strong>Random Operations:</strong> Get random members for sampling</li>
                    <li class="bullet-point"><strong>Cardinality:</strong> Count unique elements efficiently</li>
                </ul>
                
                <div class="success">
                    <strong>Analytics Use Case:</strong> Set operations are perfect for customer segmentation, A/B testing groups, and feature flag management.
                </div>
            </section>

            <!-- Set Operations Code Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Set Operations - Basic Examples</h3>
                </div>
                <div class="code-block">
// Add multiple unique tags to a customer
await client.sAdd('customer:1001:tags', 'premium', 'loyal', 'high-value');
await client.sAdd('customer:1001:tags', 'premium'); // Duplicate ignored

// Check if customer has specific tag
const isPremium = await client.sIsMember('customer:1001:tags', 'premium');
console.log('Customer is premium:', isPremium); // true

// Get all tags for customer
const customerTags = await client.sMembers('customer:1001:tags');
console.log('Customer tags:', customerTags);

// Count unique tags
const tagCount = await client.sCard('customer:1001:tags');

// Remove tags
await client.sRem('customer:1001:tags', 'temporary-tag');

// Get and remove random tag
const randomTag = await client.sPop('customer:1001:tags');
</div>
            </section>

            <!-- Set Operations Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Set Operations</h3>
                </div>
                <h4>Set Mathematics for Customer Analytics</h4>
                <p>Use set operations to analyze customer segments and find relationships between different groups:</p>
                <div class="code-block">
// Create customer groups
await client.sAdd('group:premium', '1001', '1002', '1003', '1004');
await client.sAdd('group:loyal', '1001', '1004', '1005', '1006');
await client.sAdd('group:young', '1002', '1005', '1007', '1008');

// Find customers who are both premium AND loyal
const premiumLoyal = await client.sInter('group:premium', 'group:loyal');
console.log('Premium + Loyal customers:', premiumLoyal); // ['1001', '1004']

// Find all premium OR loyal customers
const premiumOrLoyal = await client.sUnion('group:premium', 'group:loyal');

// Find premium customers who are NOT loyal
const premiumNotLoyal = await client.sDiff('group:premium', 'group:loyal');

// Store intersection result for later use
await client.sInterStore('group:premium_loyal', 'group:premium', 'group:loyal');
</div>
                <div class="success">
                    <strong>Analytics Use Case:</strong> Set operations are perfect for customer segmentation, A/B testing groups, and feature flag management.
                </div>
            </section>

            <!-- Sorted Sets Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Redis Sorted Sets - Ranked Data</h3>
                </div>
                <h4>Score-Based Ordering and Rankings</h4>
                <p>Sorted sets combine the uniqueness of sets with automatic ordering by score, perfect for leaderboards and rankings:</p>
                <div class="code-block">
// Add customers with their premium amounts as scores
await client.zAdd('leaderboard:premium_value', [
    { score: 1500.50, value: 'customer:1001' },
    { score: 1200.75, value: 'customer:1002' },
    { score: 1800.25, value: 'customer:1003' },
    { score: 950.00, value: 'customer:1004' }
]);

// Get top customers by premium value (highest first)
const topCustomers = await client.zRevRange(
    'leaderboard:premium_value', 0, 2, { WITHSCORES: true }
);
console.log('Top 3 premium customers:', topCustomers);

// Get customer's rank (0-based, highest score = rank 0)
const customerRank = await client.zRevRank(
    'leaderboard:premium_value', 'customer:1001'
);
console.log('Customer 1001 rank:', customerRank + 1);
</div>
            </section>

            <!-- Sorted Sets Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Sorted Set Operations</h3>
                </div>
                <h4>Range Queries and Score-Based Analytics</h4>
                <p>Sorted sets excel at range queries and score-based filtering for business analytics:</p>
                <div class="code-block">
// Find customers with premium value above $1400
const highValueCustomers = await client.zRangeByScore(
    'leaderboard:premium_value', 1400, '+inf', { WITHSCORES: true }
);

// Count customers in specific premium range
const midTierCount = await client.zCount(
    'leaderboard:premium_value', 1000, 1500
);

// Get customer's current score
const customerScore = await client.zScore(
    'leaderboard:premium_value', 'customer:1001'
);

// Update customer's score (increment by amount)
await client.zIncrBy('leaderboard:premium_value', 200.50, 'customer:1001');

// Remove customers below minimum threshold
await client.zRemRangeByScore('leaderboard:premium_value', 0, 500);

// Get customers within rank range
const middleRanked = await client.zRange(
    'leaderboard:premium_value', 5, 10, { WITHSCORES: true }
);
</div>
                <div class="info">
                    <strong>Business Use:</strong> Perfect for premium tiers, loyalty points, credit scores, and any ranking system where order matters.
                </div>
            </section>

            <!-- Lab Introduction -->
            <section>
                <div class="lab-callout">
                    <h3>üõ†Ô∏è Lab 4: JavaScript Redis Integration</h3>
                    <p><strong>Duration:</strong> 45 minutes</p>
                    <p>Build a customer data management application using Node.js and Redis</p>
                </div>
            </section>

            <!-- Error Handling Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Error Handling Strategies</h3>
                </div>
                <h4>Robust Error Management Patterns</h4>
                <p>Implement comprehensive error handling to ensure application stability and provide meaningful feedback:</p>
                <div class="code-block">
async function safeRedisOperation(key, operation) {
    try {
        const result = await operation();
        return { success: true, data: result };
    } catch (error) {
        console.error(`Redis operation failed for key ${key}:`, error);
        
        // Handle specific error types
        if (error.code === 'ECONNREFUSED') {
            console.log('Redis connection refused - server down?');
            // Trigger reconnection logic or fallback
        } else if (error.code === 'ENOTFOUND') {
            console.log('Redis host not found - check configuration');
        }
        
        return { success: false, error: error.message };
    }
}
</div>
            </section>

            <!-- Error Handling Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Error Handling</h3>
                </div>
                <h4>Circuit Breaker and Fallback Patterns</h4>
                <p>Implement circuit breaker patterns to handle Redis outages gracefully and maintain application availability:</p>
                <div class="code-block">
class RedisCircuitBreaker {
    constructor(threshold = 5, timeout = 60000) {
        this.failureCount = 0;
        this.threshold = threshold;
        this.timeout = timeout;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.nextAttempt = Date.now();
    }
    
    async execute(operation) {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
        }
        
        try {
            const result = await operation();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
    
    onSuccess() {
        this.failureCount = 0;
        this.state = 'CLOSED';
    }
    
    onFailure() {
        this.failureCount++;
        if (this.failureCount >= this.threshold) {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.timeout;
        }
    }
}
</div>
            </section>

            <!-- Connection Management Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Connection Lifecycle Management</h3>
                </div>
                <h4>Professional Connection Handling</h4>
                <p>Implement proper connection management with monitoring and automatic recovery for production applications:</p>
                <div class="code-block">
class RedisConnectionManager {
    constructor(config) {
        this.config = config;
        this.client = null;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
    }
    
    async connect() {
        if (this.client && this.client.isOpen) {
            return this.client;
        }
        
        if (this.isConnecting) {
            // Wait for existing connection attempt
            while (this.isConnecting) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return this.client;
        }
        
        this.isConnecting = true;
        
        try {
            this.client = redis.createClient(this.config);
            this.setupEventHandlers();
            await this.client.connect();
            this.reconnectAttempts = 0;
            this.isConnecting = false;
            return this.client;
        } catch (error) {
            this.isConnecting = false;
            throw error;
        }
    }
</div>
            </section>

            <!-- Connection Management Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Connection Features</h3>
                </div>
                <h4>Event Handling and Monitoring</h4>
                <p>Set up comprehensive event monitoring to track connection health and performance:</p>
                <div class="code-block">
    setupEventHandlers() {
        this.client.on('connect', () => {
            console.log('‚úÖ Redis connected successfully');
            this.reconnectAttempts = 0;
        });
        
        this.client.on('ready', () => {
            console.log('üöÄ Redis client ready for operations');
        });
        
        this.client.on('error', (err) => {
            console.error('‚ùå Redis connection error:', err.message);
            this.handleConnectionError(err);
        });
        
        this.client.on('end', () => {
            console.log('üîå Redis connection ended');
        });
        
        this.client.on('reconnecting', () => {
            this.reconnectAttempts++;
            console.log(`üîÑ Reconnecting to Redis (attempt ${this.reconnectAttempts})`);
        });
    }
    
    async disconnect() {
        if (this.client) {
            await this.client.disconnect();
            this.client = null;
            console.log('üëã Redis disconnected cleanly');
        }
    }
    
    isHealthy() {
        return this.client && this.client.isOpen;
    }
}
</div>
            </section>

            <!-- Async/Await Patterns Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Modern JavaScript Patterns</h3>
                </div>
                <h4>Async/Await with Redis Operations</h4>
                <p>Leverage modern JavaScript async patterns for clean, readable Redis code with proper error handling:</p>
                <div class="code-block">
async function processCustomerData(customerId) {
    try {
        // Sequential operations when data depends on previous results
        const customerExists = await client.exists(`customer:${customerId}`);
        if (!customerExists) {
            throw new Error(`Customer ${customerId} not found`);
        }
        
        const customerInfo = await client.hGetAll(`customer:${customerId}:profile`);
        
        // Use customer data to determine what other data to fetch
        const dataPromises = [
            client.lRange(`customer:${customerId}:claims`, 0, -1),
            client.sMembers(`customer:${customerId}:preferences`)
        ];
        
        // Add policy data if customer is premium
        if (customerInfo.premium === 'true') {
            dataPromises.push(
                client.zRange(`customer:${customerId}:policies`, 0, -1, 
                    { WITHSCORES: true })
            );
        }
        
        const results = await Promise.all(dataPromises);
        return this.formatCustomerResponse(customerInfo, results);
        
    } catch (error) {
        console.error('Failed to process customer data:', error);
        throw new CustomerDataError(`Cannot process customer ${customerId}`, error);
    }
}
</div>
            </section>

            <!-- Async/Await Patterns Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Performance Optimization Patterns</h3>
                </div>
                <h4>Parallel Operations and Batch Processing</h4>
                <p>Optimize performance by running independent Redis operations in parallel and batching related operations:</p>
                <div class="code-block">
async function getCustomerDashboardData(customerId) {
    // Run all independent operations in parallel
    const [
        customerProfile,
        recentClaims,
        policyData,
        activityLog,
        preferences,
        loyaltyPoints
    ] = await Promise.all([
        client.hGetAll(`customer:${customerId}:profile`),
        client.lRange(`customer:${customerId}:claims`, 0, 4),
        client.zRevRange(`customer:${customerId}:policies`, 0, -1, 
            { WITHSCORES: true }),
        client.lRange(`customer:${customerId}:activities`, 0, 9),
        client.sMembers(`customer:${customerId}:preferences`),
        client.zScore('loyalty_leaderboard', customerId)
    ]);
    
    return {
        profile: customerProfile,
        recentClaims: recentClaims.map(claim => JSON.parse(claim)),
        policies: this.formatPolicyData(policyData),
        activities: activityLog.map(activity => JSON.parse(activity)),
        preferences: preferences,
        loyaltyPoints: loyaltyPoints || 0,
        timestamp: new Date().toISOString()
    };
}

// Handle Promise.all failures gracefully
async function safeParallelOperations(operations) {
    const results = await Promise.allSettled(operations);
    return results.map((result, index) => {
        if (result.status === 'fulfilled') {
            return result.value;
        } else {
            console.error(`Operation ${index} failed:`, result.reason);
            return null; // or appropriate default value
        }
    });
}
</div>
            </section>

            <!-- Pipeline Operations Part 1 -->
            <section>
                <div class="session-header">
                    <h3>Pipeline Operations for Performance</h3>
                </div>
                <h4>Batch Operations with Redis Multi/Pipeline</h4>
                <p>Use pipelines to send multiple commands in a single network round trip, dramatically improving performance for batch operations:</p>
                <div class="code-block">
async function batchUpdateCustomers(customers) {
    const pipeline = client.multi();
    
    // Queue multiple operations without waiting for responses
    customers.forEach(customer => {
        // Update customer profile
        pipeline.hSet(`customer:${customer.id}:profile`, {
            name: customer.name,
            email: customer.email,
            last_updated: new Date().toISOString()
        });
        
        // Add to active customers set
        pipeline.sAdd('active_customers', customer.id);
        
        // Update customer score in leaderboard
        pipeline.zAdd('customer_value_leaderboard', {
            score: customer.totalValue,
            value: customer.id
        });
        
        // Log the update activity
        pipeline.lPush(`customer:${customer.id}:activities`, 
            JSON.stringify({
                action: 'profile_update',
                timestamp: Date.now()
            })
        );
    });
    
    // Execute all operations atomically
    const results = await pipeline.exec();
    console.log(`Batch update completed: ${results.length} operations executed`);
    return results;
}
</div>
            </section>

            <!-- Pipeline Operations Part 2 -->
            <section>
                <div class="session-header">
                    <h3>Advanced Pipeline Techniques</h3>
                </div>
                <h4>Transaction Safety and Error Handling</h4>
                <p>Handle pipeline results and implement transaction-like behavior with proper error management:</p>
                <div class="code-block">
async function safeCustomerTransaction(customerId, updates) {
    const pipeline = client.multi();
    
    try {
        // Watch key for changes (optimistic locking)
        await client.watch(`customer:${customerId}:profile`);
        
        // Verify customer exists before updates
        const exists = await client.exists(`customer:${customerId}:profile`);
        if (!exists) {
            await client.unwatch();
            throw new Error(`Customer ${customerId} does not exist`);
        }
        
        // Queue conditional updates
        Object.entries(updates).forEach(([field, value]) => {
            pipeline.hSet(`customer:${customerId}:profile`, field, value);
        });
        
        // Add audit trail
        pipeline.lPush(`customer:${customerId}:audit`, JSON.stringify({
            action: 'profile_update',
            changes: updates,
            timestamp: new Date().toISOString(),
            user: 'system'
        }));
        
        const results = await pipeline.exec();
        
        if (!results) {
            throw new Error('Transaction failed - key was modified during execution');
        }
        
        console.log('Customer update transaction completed successfully');
        return results;
        
    } catch (error) {
        await client.unwatch(); // Clean up watch
        console.error('Customer transaction failed:', error);
        throw error;
    }
}
</div>
                <div class="warning">
                    <strong>Important:</strong> Pipeline operations are atomic but not transactional. Use WATCH/MULTI/EXEC for true transactional behavior.
                </div>
            </section>

            <!-- Redis Streams -->
            <section>
                <div class="session-header">
                    <h3>Working with Redis Streams</h3>
                </div>
                <h4>Event Streaming for Customer Activities</h4>
                <div class="code-block">
// Add to stream
async function logCustomerActivity(customerId, activity) {
    const streamKey = `customer:${customerId}:activities`;
    
    await client.xAdd(streamKey, '*', {
        action: activity.action,
        timestamp: Date.now(),
        details: JSON.stringify(activity.details)
    });
}

// Read from stream
async function getCustomerActivities(customerId, count = 10) {
    const streamKey = `customer:${customerId}:activities`;
    
    const activities = await client.xRevRange(streamKey, '+', '-', {
        COUNT: count
    });
    
    return activities.map(activity => ({
        id: activity.id,
        ...activity.message
    }));
}
</div>
            </section>

            <!-- Pub/Sub Operations -->
            <section>
                <div class="session-header">
                    <h3>Pub/Sub for Real-time Updates</h3>
                </div>
                <h4>Real-time Customer Notifications</h4>
                <div class="code-block">
// Publisher
async function notifyPolicyUpdate(customerId, policyId) {
    const message = JSON.stringify({
        customerId,
        policyId,
        timestamp: Date.now(),
        event: 'policy_updated'
    });
    
    await client.publish('policy_updates', message);
}

// Subscriber
async function setupPolicyUpdateListener() {
    const subscriber = client.duplicate();
    await subscriber.connect();
    
    await subscriber.subscribe('policy_updates', (message) => {
        const update = JSON.parse(message);
        console.log('Policy update received:', update);
        // Process the update
    });
}
</div>
            </section>

            <!-- Testing Redis Operations -->
            <section>
                <div class="session-header">
                    <h3>Testing Redis Operations</h3>
                </div>
                <h4>Unit Testing with Jest</h4>
                <div class="code-block">
const redis = require('redis-mock');

describe('Customer Service', () => {
    let client;
    
    beforeEach(() => {
        client = redis.createClient();
    });
    
    afterEach(() => {
        client.flushall();
    });
    
    test('should store customer data', async () => {
        await client.hSet('customer:1001', 'name', 'John Doe');
        const name = await client.hGet('customer:1001', 'name');
        expect(name).toBe('John Doe');
    });
});
</div>
                <div class="info">
                    <strong>Testing Tip:</strong> Use redis-mock for unit tests to avoid dependencies on actual Redis instances.
                </div>
            </section>

            <!-- Monitoring and Debugging -->
            <section>
                <div class="session-header">
                    <h3>Monitoring and Debugging</h3>
                </div>
                <h4>Debugging Redis Operations</h4>
                <div class="code-block">
// Enable command logging
client.on('ready', () => {
    console.log('Redis client ready');
});

client.on('error', (err) => {
    console.error('Redis error:', err);
});

// Monitor commands (development only)
if (process.env.NODE_ENV === 'development') {
    client.monitor((err, res) => {
        console.log('Entering monitoring mode.');
    });
    
    client.on('monitor', (time, args) => {
        console.log('Redis command:', args);
    });
}
</div>
            </section>

            <!-- Production Considerations -->
            <section>
                <div class="session-header">
                    <h3>Production Considerations</h3>
                </div>
                <div class="two-column">
                    <div class="column">
                        <h4>Performance Optimization</h4>
                        <ul>
                            <li class="bullet-point">Use connection pooling</li>
                            <li class="bullet-point">Implement proper error handling</li>
                            <li class="bullet-point">Use pipelines for batch operations</li>
                            <li class="bullet-point">Monitor memory usage</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h4>Security Best Practices</h4>
                        <ul>
                            <li class="bullet-point">Use authentication</li>
                            <li class="bullet-point">Enable SSL/TLS</li>
                            <li class="bullet-point">Validate input data</li>
                            <li class="bullet-point">Implement rate limiting</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Session Summary -->
            <section>
                <div class="session-header">
                    <h2>Session Summary</h2>
                </div>
                <ul>
                    <li class="bullet-point">Successfully configured Node.js Redis client</li>
                    <li class="bullet-point">Implemented all major Redis data types in JavaScript</li>
                    <li class="bullet-point">Applied error handling and connection management</li>
                    <li class="bullet-point">Built data management workflows</li>
                    <li class="bullet-point">Explored advanced features like streams and pub/sub</li>
                </ul>
                <div class="success">
                    <strong>Next:</strong> We'll explore Set and Sorted Set applications for analytics and reporting.
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            controls: true,
            progress: true,
            center: false,
            transition: 'slide',
            width: 1400,
            height: 1000,
            margin: 0.05,
            minScale: 0.1,
            maxScale: 1.2
        });
    </script>
</body>
</html>